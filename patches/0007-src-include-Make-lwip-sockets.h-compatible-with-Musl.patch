From e245cb8fe567f6988ca1a008f4c63cbf4027558f Mon Sep 17 00:00:00 2001
Message-Id: <e245cb8fe567f6988ca1a008f4c63cbf4027558f.1668957138.git.razvand@unikraft.io>
From: Razvan Deaconescu <razvand@unikraft.io>
Date: Sun, 20 Nov 2022 17:10:44 +0200
Subject: [PATCH 1/4] src/include: Make lwip/sockets.h compatible with Musl

Remove functions, macros, and variables from `src/include/lwip/sockets.h`
to make it compatible with Musl.

Signed-off-by: Razvan Deaconescu <razvand@unikraft.io>
---
 src/include/lwip/sockets.h | 478 +------------------------------------
 1 file changed, 5 insertions(+), 473 deletions(-)

diff --git a/src/include/lwip/sockets.h b/src/include/lwip/sockets.h
index 1d3209c..59c6b65 100644
--- a/src/include/lwip/sockets.h
+++ b/src/include/lwip/sockets.h
@@ -41,269 +41,19 @@
 
 #include <uk/config.h>
 
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <poll.h>
+
 #include "lwip/opt.h"
 
 #if LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
 
-#include "lwip/ip_addr.h"
-#include "lwip/netif.h"
-#include "lwip/err.h"
-#include "lwip/inet.h"
-#include "lwip/errno.h"
-
-#include <string.h>
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-/* If your port already typedef's sa_family_t, define SA_FAMILY_T_DEFINED
-   to prevent this code from redefining it. */
-#if !defined(sa_family_t) && !defined(SA_FAMILY_T_DEFINED)
-typedef u8_t sa_family_t;
-#endif
-/* If your port already typedef's in_port_t, define IN_PORT_T_DEFINED
-   to prevent this code from redefining it. */
-#if !defined(in_port_t) && !defined(IN_PORT_T_DEFINED)
-typedef u16_t in_port_t;
-#endif
-
-#if LWIP_IPV4
-/* members are in network byte order */
-struct sockaddr_in {
-  u8_t            sin_len;
-  sa_family_t     sin_family;
-  in_port_t       sin_port;
-  struct in_addr  sin_addr;
-#define SIN_ZERO_LEN 8
-  char            sin_zero[SIN_ZERO_LEN];
-};
-#endif /* LWIP_IPV4 */
-
-#if LWIP_IPV6
-struct sockaddr_in6 {
-  u8_t            sin6_len;      /* length of this structure    */
-  sa_family_t     sin6_family;   /* AF_INET6                    */
-  in_port_t       sin6_port;     /* Transport layer port #      */
-  u32_t           sin6_flowinfo; /* IPv6 flow information       */
-  struct in6_addr sin6_addr;     /* IPv6 address                */
-  u32_t           sin6_scope_id; /* Set of interfaces for scope */
-};
-#endif /* LWIP_IPV6 */
-
-struct sockaddr {
-  u8_t        sa_len;
-  sa_family_t sa_family;
-  char        sa_data[14];
-};
-
-struct sockaddr_storage {
-  u8_t        s2_len;
-  sa_family_t ss_family;
-  char        s2_data1[2];
-  u32_t       s2_data2[3];
-#if LWIP_IPV6
-  u32_t       s2_data3[3];
-#endif /* LWIP_IPV6 */
-};
-
-/* If your port already typedef's socklen_t, define SOCKLEN_T_DEFINED
-   to prevent this code from redefining it. */
-#if !defined(socklen_t) && !defined(SOCKLEN_T_DEFINED)
-typedef u32_t socklen_t;
-#endif
-
-#if !defined IOV_MAX
-#define IOV_MAX 0xFFFF
-#elif IOV_MAX > 0xFFFF
-#error "IOV_MAX larger than supported by LwIP"
-#endif /* IOV_MAX */
-
-#if !defined(iovec)
-struct iovec {
-  void  *iov_base;
-  size_t iov_len;
-};
-#endif
-
-struct msghdr {
-  void         *msg_name;
-  socklen_t     msg_namelen;
-  struct iovec *msg_iov;
-  int           msg_iovlen;
-  void         *msg_control;
-  socklen_t     msg_controllen;
-  int           msg_flags;
-};
-
-/* struct msghdr->msg_flags bit field values */
-#define MSG_TRUNC   0x04
-#define MSG_CTRUNC  0x08
-
-/* RFC 3542, Section 20: Ancillary Data */
-struct cmsghdr {
-  socklen_t  cmsg_len;   /* number of bytes, including header */
-  int        cmsg_level; /* originating protocol */
-  int        cmsg_type;  /* protocol-specific type */
-};
-/* Data section follows header and possible padding, typically referred to as
-      unsigned char cmsg_data[]; */
-
-/* cmsg header/data alignment. NOTE: we align to native word size (double word
-size on 16-bit arch) so structures are not placed at an unaligned address.
-16-bit arch needs double word to ensure 32-bit alignment because socklen_t
-could be 32 bits. If we ever have cmsg data with a 64-bit variable, alignment
-will need to increase long long */
-#define ALIGN_H(size) (((size) + sizeof(long) - 1U) & ~(sizeof(long)-1U))
-#define ALIGN_D(size) ALIGN_H(size)
-
-#define CMSG_FIRSTHDR(mhdr) \
-          ((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \
-           (struct cmsghdr *)(mhdr)->msg_control : \
-           (struct cmsghdr *)NULL)
-
-#define CMSG_NXTHDR(mhdr, cmsg) \
-        (((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \
-         (((u8_t *)(cmsg) + ALIGN_H((cmsg)->cmsg_len) \
-                            + ALIGN_D(sizeof(struct cmsghdr)) > \
-           (u8_t *)((mhdr)->msg_control) + (mhdr)->msg_controllen) ? \
-          (struct cmsghdr *)NULL : \
-          (struct cmsghdr *)((void*)((u8_t *)(cmsg) + \
-                                      ALIGN_H((cmsg)->cmsg_len)))))
-
-#define CMSG_DATA(cmsg) ((void*)((u8_t *)(cmsg) + \
-                         ALIGN_D(sizeof(struct cmsghdr))))
-
-#define CMSG_SPACE(length) (ALIGN_D(sizeof(struct cmsghdr)) + \
-                            ALIGN_H(length))
-
-#define CMSG_LEN(length) (ALIGN_D(sizeof(struct cmsghdr)) + \
-                           length)
-
-/* Set socket options argument */
-#define IFNAMSIZ NETIF_NAMESIZE
-struct ifreq {
-  char ifr_name[IFNAMSIZ]; /* Interface name */
-	union {
-		struct sockaddr ifru_addr;
-		struct sockaddr ifru_dstaddr;
-		struct sockaddr ifru_broadaddr;
-		struct sockaddr ifru_netmask;
-		struct sockaddr ifru_hwaddr;
-		short int ifru_flags;
-		int ifru_ivalue;
-		int ifru_mtu;
-		/*struct ifmap ifru_map;*/
-		char ifru_slave[IFNAMSIZ];
-		char ifru_newname[IFNAMSIZ];
-		char *ifru_data;
-	} ifr_ifru;
-};
-
-#define ifr_hwaddr	ifr_ifru.ifru_hwaddr
-#define ifr_addr	ifr_ifru.ifru_addr
-#define ifr_dstaddr	ifr_ifru.ifru_dstaddr
-#define ifr_broadaddr	ifr_ifru.ifru_broadaddr
-#define ifr_netmask	ifr_ifru.ifru_netmask
-#define ifr_flags	ifr_ifru.ifru_flags
-#define ifr_metric	ifr_ifru.ifru_ivalue
-#define ifr_mtu		ifr_ifru.ifru_mtu
-#define ifr_map		ifr_ifru.ifru_map
-#define ifr_slave	ifr_ifru.ifru_slave
-#define ifr_data	ifr_ifru.ifru_data
-#define ifr_ifindex	ifr_ifru.ifru_ivalue
-#define ifr_bandwidth	ifr_ifru.ifru_ivalue
-#define ifr_qlen	ifr_ifru.ifru_ivalue
-#define ifr_newname	ifr_ifru.ifru_newname
-
-/* Socket protocol types (TCP/UDP/RAW) */
-#define SOCK_STREAM     1
-#define SOCK_DGRAM      2
-#define SOCK_RAW        3
-
-/*
- * Option flags per-socket. These must match the SOF_ flags in ip.h (checked in init.c)
- */
-#define SO_REUSEADDR   0x0004 /* Allow local address reuse */
-#define SO_KEEPALIVE   0x0008 /* keep connections alive */
-#define SO_BROADCAST   0x0020 /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
-
-
-/*
- * Additional options, not kept in so_options.
- */
-#define SO_DEBUG        0x0001 /* Unimplemented: turn on debugging info recording */
-#define SO_ACCEPTCONN   0x0002 /* socket has had listen() */
-#define SO_DONTROUTE    0x0010 /* Unimplemented: just use interface addresses */
-#define SO_USELOOPBACK  0x0040 /* Unimplemented: bypass hardware when possible */
-#define SO_LINGER       0x0080 /* linger on close if data present */
-#define SO_DONTLINGER   ((int)(~SO_LINGER))
-#define SO_OOBINLINE    0x0100 /* Unimplemented: leave received OOB data in line */
-#define SO_REUSEPORT    0x0200 /* Unimplemented: allow local address & port reuse */
-#define SO_SNDBUF       0x1001 /* Unimplemented: send buffer size */
-#define SO_RCVBUF       0x1002 /* receive buffer size */
-#define SO_SNDLOWAT     0x1003 /* Unimplemented: send low-water mark */
-#define SO_RCVLOWAT     0x1004 /* Unimplemented: receive low-water mark */
-#define SO_SNDTIMEO     0x1005 /* send timeout */
-#define SO_RCVTIMEO     0x1006 /* receive timeout */
-#define SO_ERROR        0x1007 /* get error status and clear */
-#define SO_TYPE         0x1008 /* get socket type */
-#define SO_CONTIMEO     0x1009 /* Unimplemented: connect timeout */
-#define SO_NO_CHECK     0x100a /* don't create UDP checksum */
-#define SO_BINDTODEVICE 0x100b /* bind to device */
-
-/*
- * Structure used for manipulating linger option.
- */
-struct linger {
-  int l_onoff;                /* option on/off */
-  int l_linger;               /* linger time in seconds */
-};
-
-/*
- * Level number for (get/set)sockopt() to apply to socket itself.
- */
-#define  SOL_SOCKET  0xfff    /* options for socket level */
-
-
-#define AF_UNSPEC       0
-#define AF_INET         2
-#if LWIP_IPV6
-#define AF_INET6        10
-#else /* LWIP_IPV6 */
-#define AF_INET6        AF_UNSPEC
-#endif /* LWIP_IPV6 */
-#define PF_INET         AF_INET
-#define PF_INET6        AF_INET6
-#define PF_UNSPEC       AF_UNSPEC
-
-#define IPPROTO_IP      0
-#define IPPROTO_ICMP    1
-#define IPPROTO_TCP     6
-#define IPPROTO_UDP     17
-#if LWIP_IPV6
-#define IPPROTO_IPV6    41
-#define IPPROTO_ICMPV6  58
-#endif /* LWIP_IPV6 */
-#define IPPROTO_UDPLITE 136
-#define IPPROTO_RAW     255
-
-/* Flags we can use with send and recv. */
-#define MSG_PEEK       0x01    /* Peeks at an incoming message */
-#define MSG_WAITALL    0x02    /* Unimplemented: Requests that the function block until the full amount of data requested can be returned */
-#define MSG_OOB        0x04    /* Unimplemented: Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific */
-#define MSG_DONTWAIT   0x08    /* Nonblocking i/o for this operation only */
-#define MSG_MORE       0x10    /* Sender will send more */
-#define MSG_NOSIGNAL   0x20    /* Uninmplemented: Requests not to send the SIGPIPE signal if an attempt to send is made on a stream-oriented socket that is no longer connected. */
-
-
-/*
- * Options for level IPPROTO_IP
- */
-#define IP_TOS             1
-#define IP_TTL             2
-#define IP_PKTINFO         8
-
 #if LWIP_TCP
 /*
  * Options for level IPPROTO_TCP
@@ -315,188 +65,6 @@ struct linger {
 #define TCP_KEEPCNT    0x05    /* set pcb->keep_cnt   - Use number of probes sent for get/setsockopt */
 #endif /* LWIP_TCP */
 
-#if LWIP_IPV6
-/*
- * Options for level IPPROTO_IPV6
- */
-#define IPV6_CHECKSUM       7  /* RFC3542: calculate and insert the ICMPv6 checksum for raw sockets. */
-#define IPV6_V6ONLY         27 /* RFC3493: boolean control to restrict AF_INET6 sockets to IPv6 communications only. */
-#endif /* LWIP_IPV6 */
-
-#if LWIP_UDP && LWIP_UDPLITE
-/*
- * Options for level IPPROTO_UDPLITE
- */
-#define UDPLITE_SEND_CSCOV 0x01 /* sender checksum coverage */
-#define UDPLITE_RECV_CSCOV 0x02 /* minimal receiver checksum coverage */
-#endif /* LWIP_UDP && LWIP_UDPLITE*/
-
-
-#if LWIP_MULTICAST_TX_OPTIONS
-/*
- * Options and types for UDP multicast traffic handling
- */
-#define IP_MULTICAST_TTL   5
-#define IP_MULTICAST_IF    6
-#define IP_MULTICAST_LOOP  7
-#endif /* LWIP_MULTICAST_TX_OPTIONS */
-
-#if LWIP_IGMP
-/*
- * Options and types related to multicast membership
- */
-#define IP_ADD_MEMBERSHIP  3
-#define IP_DROP_MEMBERSHIP 4
-
-typedef struct ip_mreq {
-    struct in_addr imr_multiaddr; /* IP multicast address of group */
-    struct in_addr imr_interface; /* local IP address of interface */
-} ip_mreq;
-#endif /* LWIP_IGMP */
-
-#if LWIP_IPV4
-struct in_pktinfo {
-  unsigned int   ipi_ifindex;  /* Interface index */
-  struct in_addr ipi_spec_dst;	/* Routing destination address  */
-  struct in_addr ipi_addr;     /* Destination (from header) address */
-};
-#endif /* LWIP_IPV4 */
-
-#if LWIP_IPV6_MLD
-/*
- * Options and types related to IPv6 multicast membership
- */
-#define IPV6_JOIN_GROUP      12
-#define IPV6_ADD_MEMBERSHIP  IPV6_JOIN_GROUP
-#define IPV6_LEAVE_GROUP     13
-#define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP
-
-typedef struct ipv6_mreq {
-  struct in6_addr ipv6mr_multiaddr; /*  IPv6 multicast addr */
-  unsigned int    ipv6mr_interface; /*  interface index, or 0 */
-} ipv6_mreq;
-#endif /* LWIP_IPV6_MLD */
-
-/*
- * The Type of Service provides an indication of the abstract
- * parameters of the quality of service desired.  These parameters are
- * to be used to guide the selection of the actual service parameters
- * when transmitting a datagram through a particular network.  Several
- * networks offer service precedence, which somehow treats high
- * precedence traffic as more important than other traffic (generally
- * by accepting only traffic above a certain precedence at time of high
- * load).  The major choice is a three way tradeoff between low-delay,
- * high-reliability, and high-throughput.
- * The use of the Delay, Throughput, and Reliability indications may
- * increase the cost (in some sense) of the service.  In many networks
- * better performance for one of these parameters is coupled with worse
- * performance on another.  Except for very unusual cases at most two
- * of these three indications should be set.
- */
-#define IPTOS_TOS_MASK          0x1E
-#define IPTOS_TOS(tos)          ((tos) & IPTOS_TOS_MASK)
-#define IPTOS_LOWDELAY          0x10
-#define IPTOS_THROUGHPUT        0x08
-#define IPTOS_RELIABILITY       0x04
-#define IPTOS_LOWCOST           0x02
-#define IPTOS_MINCOST           IPTOS_LOWCOST
-
-/*
- * The Network Control precedence designation is intended to be used
- * within a network only.  The actual use and control of that
- * designation is up to each network. The Internetwork Control
- * designation is intended for use by gateway control originators only.
- * If the actual use of these precedence designations is of concern to
- * a particular network, it is the responsibility of that network to
- * control the access to, and use of, those precedence designations.
- */
-#define IPTOS_PREC_MASK                 0xe0
-#define IPTOS_PREC(tos)                ((tos) & IPTOS_PREC_MASK)
-#define IPTOS_PREC_NETCONTROL           0xe0
-#define IPTOS_PREC_INTERNETCONTROL      0xc0
-#define IPTOS_PREC_CRITIC_ECP           0xa0
-#define IPTOS_PREC_FLASHOVERRIDE        0x80
-#define IPTOS_PREC_FLASH                0x60
-#define IPTOS_PREC_IMMEDIATE            0x40
-#define IPTOS_PREC_PRIORITY             0x20
-#define IPTOS_PREC_ROUTINE              0x00
-
-
-/*
- * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
- * lwip_ioctl only supports FIONREAD and FIONBIO, for now
- *
- * Ioctl's have the command encoded in the lower word,
- * and the size of any in or out parameters in the upper
- * word.  The high 2 bits of the upper word are used
- * to encode the in/out status of the parameter; for now
- * we restrict parameters to at most 128 bytes.
- */
-#if !defined(FIONREAD) || !defined(FIONBIO)
-#define IOCPARM_MASK    0x7fU           /* parameters must be < 128 bytes */
-#define IOC_VOID        0x20000000UL    /* no parameters */
-#define IOC_OUT         0x40000000UL    /* copy out parameters */
-#define IOC_IN          0x80000000UL    /* copy in parameters */
-#define IOC_INOUT       (IOC_IN|IOC_OUT)
-                                        /* 0x20000000 distinguishes new &
-                                           old ioctl's */
-#define _IO(x,y)        ((long)(IOC_VOID|((x)<<8)|(y)))
-
-#define _IOR(x,y,t)     ((long)(IOC_OUT|((sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y)))
-
-#define _IOW(x,y,t)     ((long)(IOC_IN|((sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y)))
-#endif /* !defined(FIONREAD) || !defined(FIONBIO) */
-
-#ifndef FIONREAD
-#define FIONREAD    _IOR('f', 127, unsigned long) /* get # bytes to read */
-#endif
-#ifndef FIONBIO
-#define FIONBIO     _IOW('f', 126, unsigned long) /* set/clear non-blocking i/o */
-#endif
-
-/* Socket I/O Controls: unimplemented */
-#ifndef SIOCSHIWAT
-#define SIOCSHIWAT  _IOW('s',  0, unsigned long)  /* set high watermark */
-#define SIOCGHIWAT  _IOR('s',  1, unsigned long)  /* get high watermark */
-#define SIOCSLOWAT  _IOW('s',  2, unsigned long)  /* set low watermark */
-#define SIOCGLOWAT  _IOR('s',  3, unsigned long)  /* get low watermark */
-#define SIOCATMARK  _IOR('s',  7, unsigned long)  /* at oob mark? */
-#endif
-
-/* commands for fnctl */
-#ifndef F_GETFL
-#define F_GETFL 3
-#endif
-#ifndef F_SETFL
-#define F_SETFL 4
-#endif
-
-#ifndef CONFIG_HAVE_LIBC
-/* File status flags and file access modes for fnctl,
-   these are bits in an int. */
-#ifndef O_NONBLOCK
-#define O_NONBLOCK  1 /* nonblocking I/O */
-#endif
-#ifndef O_NDELAY
-#define O_NDELAY    O_NONBLOCK /* same as O_NONBLOCK, for compatibility */
-#endif
-#ifndef O_RDONLY
-#define O_RDONLY    2
-#endif
-#ifndef O_WRONLY
-#define O_WRONLY    4
-#endif
-#ifndef O_RDWR
-#define O_RDWR      (O_RDONLY|O_WRONLY)
-#endif
-#endif /* CONFIG_HAVE_LIBC */
-
-#ifndef SHUT_RD
-  #define SHUT_RD   0
-  #define SHUT_WR   1
-  #define SHUT_RDWR 2
-#endif
-
 /* FD_SET used for lwip_select */
 #ifndef FD_SET
 #undef  FD_SETSIZE
@@ -524,42 +92,6 @@ typedef struct fd_set
 #define LWIP_SELECT_MAXNFDS FD_SETSIZE
 #endif /* FD_SET */
 
-/* poll-related defines and types */
-/* @todo: find a better way to guard the definition of these defines and types if already defined */
-#if !defined(POLLIN) && !defined(POLLOUT)
-#define POLLIN     0x0001
-#define POLLOUT    0x0004
-#define POLLERR    0x0008
-#define POLLNVAL   0x0020
-/* Below values are unimplemented */
-#define POLLRDNORM 0x0040
-#define POLLRDBAND 0x0080
-#define POLLPRI    0x0002
-#define POLLWRNORM 0x0100
-#define POLLWRBAND 0x0200
-#define POLLHUP    0x0010
-typedef unsigned int nfds_t;
-struct pollfd
-{
-  int fd;
-  short events;
-  short revents;
-};
-#endif
-
-/** LWIP_TIMEVAL_PRIVATE: if you want to use the struct timeval provided
- * by your system, set this to 0 and include <sys/time.h> in cc.h */
-#ifndef LWIP_TIMEVAL_PRIVATE
-#define LWIP_TIMEVAL_PRIVATE 1
-#endif
-
-#if LWIP_TIMEVAL_PRIVATE
-struct timeval {
-  long    tv_sec;         /* seconds */
-  long    tv_usec;        /* and microseconds */
-};
-#endif /* LWIP_TIMEVAL_PRIVATE */
-
 #define lwip_socket_init() /* Compatibility define, no init needed. */
 void lwip_socket_thread_init(void); /* LWIP_NETCONN_SEM_PER_THREAD==1: initialize thread-local semaphore */
 void lwip_socket_thread_cleanup(void); /* LWIP_NETCONN_SEM_PER_THREAD==1: destroy thread-local semaphore */
-- 
2.17.1

